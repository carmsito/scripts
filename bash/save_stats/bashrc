# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)

# --- Exit early if not interactive ---
case $- in
    *i*) ;;
      *) return;;
esac

# --- History settings ---
HISTCONTROL=ignoreboth
shopt -s histappend
HISTSIZE=1000
HISTFILESIZE=2000

# --- Terminal resizing ---
shopt -s checkwinsize

# --- Debian chroot setup ---
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# --- Prompt color detection ---
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# --- Git prompt source ---
if [ -f /usr/share/git/completion/git-prompt.sh ]; then
    . /usr/share/git/completion/git-prompt.sh
elif [ -f /etc/bash_completion.d/git-prompt ]; then
    . /etc/bash_completion.d/git-prompt
fi

# --- Prompt Hacker Pro (avec Git + code retour) ---
set_bash_prompt() {
    # Efface la ligne précédente du prompt
    printf "\033[2K\r"  

    local exit_code=$?
    local arrow
    if [ $exit_code -eq 0 ]; then
        arrow="\[\033[38;5;82m\]╰─❯"    # Vert
    else
        arrow="\[\033[38;5;196m\]╰─✘"   # Rouge
    fi

    PS1="\n\[\033[38;5;82m\]╭─["\
"\[\033[38;5;45m\]\u@\h"\
"\[\033[38;5;82m\]]-["\
"\[\033[38;5;226m\]\d \t"\
"\[\033[38;5;82m\]]-["\
"\[\033[38;5;10m\]\$(echo \"\$PWD\" | sed \"s|^$HOME|~|\")"\
"\[\033[38;5;245m\]\$(__git_ps1 ' (%s)')"\
"\[\033[38;5;82m\]]\n${arrow} "\
"\[\033[00m\]"
}



PROMPT_COMMAND=set_bash_prompt
unset color_prompt force_color_prompt

# --- Xterm title ---
case "$TERM" in
    xterm*|rxvt*)
        PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
        ;;
    *) ;;
esac

# --- LS color support ---
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
fi

# --- Aliases ---
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# --- Programmable completion ---
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# --- Complétion avancée façon Zsh ---
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi

# === FZF + Bash Enhancements (auto install script) ===
# --- FZF activation ---
# --- FZF activation ---
if [ -f ~/.fzf.bash ]; then
   source ~/.fzf.bash
fi

# --- Menu visuel TAB (façon Zsh) ---
if [ -n "$BASH_VERSION" ]; then
   bind 'set show-all-if-ambiguous on'
   bind 'set menu-complete-display-prefix on'
   bind '"\t":menu-complete'
   bind '"\e[Z":menu-complete-backward'
   bind 'set colored-completion-prefix on'
   bind 'set colored-stats on'
fi

# --- FZF configuration ---
if command -v fd >/dev/null 2>&1; then
   export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git .'
   export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git .'
else
   export FZF_DEFAULT_COMMAND='find . -maxdepth 1 -type f'
   export FZF_ALT_C_COMMAND='find . -maxdepth 1 -type d'
fi

export FZF_DEFAULT_OPTS="--height 60% --layout=reverse --border --ansi"

# --- Fuzzy completion function ---
fzf-complete() {
   local line cmd prefix last
   line="${READLINE_LINE}"
   if [ -z "$line" ]; then
       line=$(fc -ln -0 | awk '{$1=""; print substr($0,2)}')
   fi

   cmd=$(printf '%s' "$line" | awk '{print $1}')

   if [[ "$line" =~ [[:space:]]$ ]]; then
       prefix="$line"
       last=""
   else
       last="${line##* }"
       prefix="${line%$last}"
   fi

   if [ -n "$cmd" ] && [ "$prefix" = "" ]; then
       if [ "$line" = "$cmd" ]; then
           prefix="$cmd "
           last=""
       fi
   fi

   _fzf_browser() {
       local start_dir cur sel dirs files
       start_dir="$PWD"
       cur="$start_dir"

       while true; do
           dirs=$(find "$cur" -maxdepth 1 -mindepth 1 -type d 2>/dev/null -printf '%P/\n' | sort)
           files=$(find "$cur" -maxdepth 1 -mindepth 1 -type f 2>/dev/null -printf '%P\n' | sort)

           sel=$(
               (printf '%s\n' "./"; printf '%s\n' "../"; printf '%s\n' "$dirs"; printf '%s\n' "$files") |
               (FZF_CUR="${cur}" fzf --ansi --no-hscroll --preview-window=right:60% \
                   --prompt="${cur/#$PWD/~}> " \
                   --preview '
item={}
case "$item" in
 "./")  F="$FZF_CUR" ;;
 "../") F="$(dirname "$FZF_CUR")" ;;
 */)    item="${item%/}"; F="${FZF_CUR%/}/$item" ;;
 *)     F="${FZF_CUR%/}/$item" ;;
esac

# Normalisation du chemin
if command -v realpath >/dev/null 2>&1; then
 F="$(realpath -m -- "$F" 2>/dev/null)"
else
 while [ "${F#//*}" != "$F" ]; do F="${F//\/\//\/}"; done
 F="${F%/./}"; F="${F%/.}"
fi

title="📂  $item"
len=${#title}

# Générer dynamiquement la barre horizontale
bar=""
for ((i=0; i<len; i++)); do
 bar="${bar}-"
done

# Générer les espaces pour les lignes vides
spaces=""
for ((i=0; i<len; i++)); do
 spaces="${spaces} "
done

echo
echo "                                                      +-${bar}-------+"
echo "                                                      |   ${spaces}     |"
echo "                                                      |   $title    |"
echo "                                                      |   ${spaces}     |"
echo "                                                      +-${bar}-------+"
echo

# Preview
if [ -d "$F" ]; then
 ls -a --color=always -- "$F"
elif [ -f "$F" ]; then
 bat --style=numbers --color=always --line-range :200 -- "$F" 2>/dev/null || head -n 200 -- "$F"
else
 echo "⚠️  Aucun aperçu disponible (élément introuvable)"
fi
'
)
           )

           [ -z "$sel" ] && return 1

           case "$sel" in
               './')
                   printf '%s\n' "$cur"
                   return 0
                   ;;
               '../')
                   cur=$(dirname "$cur")
                   ;;
               */)
                   cur="$cur/${sel%/}"
                   ;;
               *)
                   printf '%s\n' "$cur/$sel"
                   return 0
                   ;;
           esac
       done
   }

   local result
   result=$(_fzf_browser) || return 1

   if [ "$cmd" = "cd" ]; then
       if [ -d "$result" ] ; then
           cd -- "$result" || return 1
       else
           cd -- "$(dirname -- "$result")" || return 1
       fi
       READLINE_LINE=''
       READLINE_POINT=0
   else
       result="${result#./}"
       READLINE_LINE="${prefix}${result}"
       READLINE_POINT=${#READLINE_LINE}
   fi
}

# --- Bind TAB to fuzzy completion ---
bind -x '"\t": fzf-complete'

# --- Add pipx local bin to PATH ---
export PATH="$PATH:/home/emmanuel/.local/bin"

# --- Complétion intelligente améliorée ---
fzf-smart-complete() {
   local line="${READLINE_LINE}"
   local prefix="${line##* }"

   # Si rien n'est écrit → ouvre ton navigateur complet
   if [[ -z "$prefix" ]]; then
       fzf-complete
       return
   fi

   # Cherche les complétions classiques Bash (fichiers, dossiers…)
   local completions
   completions=$(compgen -f -- "$prefix")
   [ -z "$completions" ] && return 0

   local count
   count=$(echo "$completions" | wc -l)

   if [ "$count" -eq 1 ]; then
       # Une seule correspondance → complète directement
       READLINE_LINE="${line%$prefix}${completions}"
       READLINE_POINT=${#READLINE_LINE}
   else
       # Plusieurs → ouvre FZF pour choisir
       local selected
       selected=$(echo "$completions" | fzf --height 40% --ansi --reverse --border \
           --prompt="Choisir ➜ " \
           --preview "if [ -d {} ]; then ls -a --color=always {}; elif [ -f {} ]; then bat --style=numbers --color=always --line-range :100 {} 2>/dev/null || head -n 100 {}; fi")
       [ -z "$selected" ] && return 0
       READLINE_LINE="${line%$prefix}${selected}"
       READLINE_POINT=${#READLINE_LINE}
   fi
}

# --- Nouveau bind TAB : auto/FZF intelligent ---
bind -x '"\t": fzf-smart-complete'
################################################################
